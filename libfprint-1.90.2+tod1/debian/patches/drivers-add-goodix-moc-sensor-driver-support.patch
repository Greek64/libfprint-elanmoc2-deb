From: "boger.wang" <boger@goodix.com>
Date: Mon, 8 Jun 2020 22:00:29 +0800
Subject: drivers: add goodix moc sensor driver support

---
 libfprint/drivers/goodixmoc/goodix.c       | 1408 ++++++++++++++++++++++++++++
 libfprint/drivers/goodixmoc/goodix.h       |   58 ++
 libfprint/drivers/goodixmoc/goodix_proto.c |  422 +++++++++
 libfprint/drivers/goodixmoc/goodix_proto.h |  232 +++++
 libfprint/meson.build                      |    6 +
 meson.build                                |    1 +
 6 files changed, 2127 insertions(+)
 create mode 100644 libfprint/drivers/goodixmoc/goodix.c
 create mode 100644 libfprint/drivers/goodixmoc/goodix.h
 create mode 100644 libfprint/drivers/goodixmoc/goodix_proto.c
 create mode 100644 libfprint/drivers/goodixmoc/goodix_proto.h

diff --git a/libfprint/drivers/goodixmoc/goodix.c b/libfprint/drivers/goodixmoc/goodix.c
new file mode 100644
index 0000000..1eed70e
--- /dev/null
+++ b/libfprint/drivers/goodixmoc/goodix.c
@@ -0,0 +1,1408 @@
+/*
+ * Goodix Moc driver for libfprint
+ * Copyright (C) 2019 Shenzhen Goodix Technology Co., Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+
+#define FP_COMPONENT "goodixmoc"
+
+#include "drivers_api.h"
+
+#include "goodix_proto.h"
+#include "goodix.h"
+
+
+/* Default enroll stages number */
+#define DEFAULT_ENROLL_SAMPLES 8
+/* Usb port setting */
+#define EP_IN (3 | FPI_USB_ENDPOINT_IN)
+#define EP_OUT (1 | FPI_USB_ENDPOINT_OUT)
+
+#define EP_IN_MAX_BUF_SIZE (2048)
+
+#define MAX_USER_ID_LEN (64)
+
+/* Command transfer timeout :ms*/
+#define CMD_TIMEOUT (1000)
+#define ACK_TIMEOUT (2000)
+#define DATA_TIMEOUT (5000)
+
+
+struct _FpiDeviceGoodixMoc
+{
+  FpDevice           parent;
+  FpiSsm            *task_ssm;
+  FpiSsm            *cmd_ssm;
+  FpiUsbTransfer    *cmd_transfer;
+  gboolean           cmd_cancelable;
+  pgxfp_sensor_cfg_t sensorcfg;
+  gint               enroll_stage;
+  gint               max_enroll_stage;
+  GCancellable      *cancellable;
+  GPtrArray         *list_result;
+  guint8             template_id[TEMPLATE_ID_SIZE];
+  gboolean           is_enroll_identify;
+
+};
+
+G_DEFINE_TYPE (FpiDeviceGoodixMoc, fpi_device_goodixmoc, FP_TYPE_DEVICE)
+
+typedef void (*SynCmdMsgCallback) (FpiDeviceGoodixMoc  *self,
+                                   gxfp_cmd_response_t *resp,
+                                   GError              *error);
+
+typedef struct
+{
+  guint8            cmd;
+  SynCmdMsgCallback callback;
+} CommandData;
+
+/******************************************************************************
+ *
+ *  fp_cmd_xxx Function
+ *
+ *****************************************************************************/
+static void
+fp_cmd_receive_cb (FpiUsbTransfer *transfer,
+                   FpDevice       *device,
+                   gpointer        user_data,
+                   GError         *error)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  CommandData *data = user_data;
+  int ret = -1, ssm_state = 0;
+  gxfp_cmd_response_t cmd_reponse = {0, };
+  pack_header header;
+  guint32 crc32_calc = 0;
+  guint16 cmd = 0;
+
+  if (error)
+    {
+      fpi_ssm_mark_failed (transfer->ssm, error);
+      return;
+    }
+  if (data == NULL)
+    {
+      fpi_ssm_mark_failed (transfer->ssm,
+                           fpi_device_error_new (FP_DEVICE_ERROR_GENERAL));
+      return;
+    }
+  ssm_state = fpi_ssm_get_cur_state (transfer->ssm);
+  /* skip zero length package */
+  if (transfer->actual_length == 0)
+    {
+      fpi_ssm_jump_to_state (transfer->ssm, ssm_state);
+      return;
+    }
+
+  ret = gx_proto_parse_header (transfer->buffer, transfer->actual_length, &header);
+  if (ret != 0)
+    {
+      fpi_ssm_mark_failed (transfer->ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Corrupted message received"));
+      return;
+    }
+
+  gx_proto_crc32_calc (transfer->buffer, PACKAGE_HEADER_SIZE + header.len, (uint8_t *) &crc32_calc);
+  if(crc32_calc != *(uint32_t *) (transfer->buffer + PACKAGE_HEADER_SIZE + header.len))
+    {
+      fpi_ssm_mark_failed (transfer->ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Package crc check failed"));
+      return;
+    }
+
+  cmd = MAKE_CMD_EX (header.cmd0, header.cmd1);
+
+  ret = gx_proto_parse_body (cmd, &transfer->buffer[PACKAGE_HEADER_SIZE], header.len, &cmd_reponse);
+  if (ret != 0)
+    {
+      fpi_ssm_mark_failed (transfer->ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Corrupted message received"));
+      return;
+    }
+  /* ack */
+  if(header.cmd0 == RESPONSE_PACKAGE_CMD)
+    {
+      if (data->cmd != cmd_reponse.parse_msg.ack_cmd)
+        {
+          fpi_ssm_mark_failed (transfer->ssm,
+                               fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                         "Unexpected response, got 0x%x",
+                                                         cmd_reponse.parse_msg.ack_cmd));
+
+          return;
+        }
+      fpi_ssm_next_state (transfer->ssm);
+      return;
+    }
+  /* data */
+  if (data->cmd != header.cmd0)
+    {
+      fpi_ssm_mark_failed (transfer->ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Unexpected cmd, got 0x%x",
+                                                     header.cmd0));
+      return;
+    }
+  if (data->callback)
+    data->callback (self, &cmd_reponse, NULL);
+
+  fpi_ssm_mark_completed (transfer->ssm);
+}
+
+
+static void
+fp_cmd_run_state (FpiSsm   *ssm,
+                  FpDevice *dev)
+{
+  FpiUsbTransfer *transfer;
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (dev);
+
+  switch (fpi_ssm_get_cur_state (ssm))
+    {
+    case FP_CMD_SEND:
+      if (self->cmd_transfer)
+        {
+          self->cmd_transfer->ssm = ssm;
+          fpi_usb_transfer_submit (g_steal_pointer (&self->cmd_transfer),
+                                   CMD_TIMEOUT,
+                                   NULL,
+                                   fpi_ssm_usb_transfer_cb,
+                                   NULL);
+        }
+      else
+        {
+          fpi_ssm_next_state (ssm);
+        }
+      break;
+
+    case FP_CMD_GET_ACK:
+      transfer = fpi_usb_transfer_new (dev);
+      transfer->ssm = ssm;
+      fpi_usb_transfer_fill_bulk (transfer, EP_IN, EP_IN_MAX_BUF_SIZE);
+      fpi_usb_transfer_submit (transfer,
+                               ACK_TIMEOUT,
+                               NULL,
+                               fp_cmd_receive_cb,
+                               fpi_ssm_get_data (ssm));
+
+      break;
+
+    case FP_CMD_GET_DATA:
+      transfer = fpi_usb_transfer_new (dev);
+      transfer->ssm = ssm;
+      fpi_usb_transfer_fill_bulk (transfer, EP_IN, EP_IN_MAX_BUF_SIZE);
+      fpi_usb_transfer_submit (transfer,
+                               self->cmd_cancelable ? 0 : DATA_TIMEOUT,
+                               self->cmd_cancelable ? self->cancellable : NULL,
+                               fp_cmd_receive_cb,
+                               fpi_ssm_get_data (ssm));
+      break;
+    }
+
+}
+
+
+static void
+fp_cmd_ssm_done (FpiSsm *ssm, FpDevice *dev, GError *error)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (dev);
+  CommandData *data = fpi_ssm_get_data (ssm);
+
+  self->cmd_ssm = NULL;
+  /* Notify about the SSM failure from here instead. */
+  if (error)
+    {
+      if (data->callback)
+        data->callback (self, NULL, error);
+      else
+        g_error_free (error);
+    }
+}
+
+static FpiUsbTransfer *
+alloc_cmd_transfer (FpDevice     *dev,
+                    guint8        cmd0,
+                    guint8        cmd1,
+                    const guint8 *data,
+                    guint16       data_len)
+{
+  gint ret = -1;
+
+  g_autoptr(FpiUsbTransfer) transfer = NULL;
+
+  guint32 total_len = data_len + PACKAGE_HEADER_SIZE + PACKAGE_CRC_SIZE;
+
+  g_return_val_if_fail (data || data_len == 0, NULL);
+
+  transfer = fpi_usb_transfer_new (dev);
+
+  fpi_usb_transfer_fill_bulk (transfer, EP_OUT, total_len);
+
+  ret = gx_proto_build_package (transfer->buffer, &total_len, MAKE_CMD_EX (cmd0, cmd1), data, data_len);
+
+  g_return_val_if_fail (ret == 0, NULL);
+
+  return g_steal_pointer (&transfer);
+}
+
+static void
+fp_cmd_ssm_done_data_free (CommandData *data)
+{
+  g_free (data);
+}
+
+static void
+goodix_sensor_cmd (FpiDeviceGoodixMoc *self,
+                   guint8              cmd0,
+                   guint8              cmd1,
+                   gboolean            bwait_data_delay,
+                   const guint8      * payload,
+                   gssize              payload_len,
+                   SynCmdMsgCallback   callback)
+{
+
+  g_autoptr(FpiUsbTransfer) transfer = NULL;
+
+  CommandData *data = g_new0 (CommandData, 1);
+
+  transfer = alloc_cmd_transfer (FP_DEVICE (self), cmd0, cmd1, payload, payload_len);
+
+  data->cmd = cmd0;
+  data->callback = callback;
+
+  self->cmd_transfer = g_steal_pointer (&transfer);
+  self->cmd_cancelable = bwait_data_delay;
+
+  self->cmd_ssm = fpi_ssm_new (FP_DEVICE (self),
+                               fp_cmd_run_state,
+                               FP_CMD_NUM_STATES);
+
+  fpi_ssm_set_data (self->cmd_ssm, data, (GDestroyNotify) fp_cmd_ssm_done_data_free);
+
+  fpi_ssm_start (self->cmd_ssm, fp_cmd_ssm_done);
+
+
+}
+/******************************************************************************
+ *
+ *  fp_verify_xxxx Function
+ *
+ *****************************************************************************/
+static void
+fp_verify_capture_cb (FpiDeviceGoodixMoc  *self,
+                      gxfp_cmd_response_t *resp,
+                      GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (resp->result >= GX_FAILED)
+    {
+      fp_dbg ("Capture sample failed, result: 0x%x", resp->result);
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_retry_new (FP_DEVICE_RETRY_GENERAL));
+      return;
+    }
+
+  if (resp->capture_data_resp.img_quality == 0)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_retry_new (FP_DEVICE_RETRY_REMOVE_FINGER));
+      return;
+    }
+  else if (resp->capture_data_resp.img_coverage < 35)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_retry_new (FP_DEVICE_RETRY_CENTER_FINGER));
+    }
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_verify_identify_cb (FpiDeviceGoodixMoc  *self,
+                       gxfp_cmd_response_t *resp,
+                       GError              *error)
+{
+  FpDevice *device = FP_DEVICE (self);
+
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (!resp->verify.match)
+    {
+      fpi_device_verify_report (device, FPI_MATCH_FAIL, NULL, error);
+    }
+  else if (memcmp (&resp->verify.template.tid, &self->template_id, TEMPLATE_ID_SIZE) != 0)
+    {
+      fpi_device_verify_report (device, FPI_MATCH_FAIL, NULL, error);
+    }
+  else
+    {
+      fp_info ("Verify successful! for user: %s finger: %d",
+               resp->verify.template.payload.data, resp->verify.template.finger_index);
+      fpi_device_verify_report (device, FPI_MATCH_SUCCESS, NULL, NULL);
+    }
+
+  fpi_ssm_mark_completed (self->task_ssm);
+
+}
+
+static void
+fp_verify_sm_run_state (FpiSsm *ssm, FpDevice *device)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  guint8 param[3] = { 0 };
+
+  param[0] = 0x01;
+  param[1] = self->sensorcfg->config[10];
+  param[2] = self->sensorcfg->config[11];
+
+  switch (fpi_ssm_get_cur_state (ssm))
+    {
+    case FP_VERIFY_CAPTURE:
+      goodix_sensor_cmd (self, MOC_CMD0_CAPTURE_DATA, MOC_CMD1_DEFAULT,
+                         true,
+                         (const guint8 *) &param,
+                         G_N_ELEMENTS (param),
+                         fp_verify_capture_cb);
+      break;
+
+    case FP_VERIFY_IDENTIFY:
+      goodix_sensor_cmd (self, MOC_CMD0_IDENTIFY, MOC_CMD1_DEFAULT,
+                         false,
+                         (const guint8 *) &self->template_id,
+                         TEMPLATE_ID_SIZE,
+                         fp_verify_identify_cb);
+      break;
+    }
+
+}
+
+static void
+fp_verify_ssm_done (FpiSsm *ssm, FpDevice *dev, GError *error)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (dev);
+
+  fp_info ("Verify complete!");
+
+  if (error && error->domain == FP_DEVICE_RETRY)
+    fpi_device_verify_report (dev, FPI_MATCH_ERROR, NULL, error);
+
+  fpi_device_verify_complete (dev, error);
+
+  self->task_ssm = NULL;
+}
+
+
+/******************************************************************************
+ *
+ *  fp__xxxx Function
+ *
+ *****************************************************************************/
+static gboolean
+encode_finger_id (
+  const guint8 * tid,
+  guint16        tid_len,
+  const guint8 * uid,
+  guint16        uid_len,
+  guint8      ** fid,
+  guint16      * fid_len
+                 )
+{
+  guint8 * buffer = NULL;
+  guint16 offset = 0;
+
+  g_return_val_if_fail (tid != NULL, FALSE);
+  g_return_val_if_fail (uid != NULL, FALSE);
+  g_return_val_if_fail (fid != NULL, FALSE);
+  g_return_val_if_fail (fid_len != NULL, FALSE);
+
+  *fid_len = (guint16) (70 + uid_len);  // must include fingerid length
+
+  *fid = (guint8 *) g_malloc0 (*fid_len + 2);
+
+  buffer = *fid;
+  offset = 0;
+  buffer[offset++] = LOBYTE (*fid_len);
+  buffer[offset++] = HIBYTE (*fid_len);
+
+  buffer[offset++] = 67;
+  buffer[offset++] = 1;
+  buffer[offset++] = 1;   // finger index
+  buffer[offset++] = 0;   //
+
+  offset += 32;
+
+  memcpy (&buffer[offset], tid, MIN (tid_len, TEMPLATE_ID_SIZE));
+  offset += 32;   // offset == 68
+
+  buffer[offset++] = uid_len;
+  memcpy (&buffer[offset], uid, uid_len);
+  offset += (guint8) uid_len;
+
+  buffer[offset++] = 0;
+
+  if (offset != (*fid_len + 2))
+    {
+      memset (buffer, 0, *fid_len);
+      *fid_len = 0;
+
+      fp_err ("offset != fid_len, %d != %d", offset, *fid_len);
+      return FALSE;
+    }
+  *fid_len += 2;
+
+  return TRUE;
+}
+/******************************************************************************
+ *
+ *  fp_enroll_xxxx Function
+ *
+ *****************************************************************************/
+
+static void
+fp_enroll_enum_cb (FpiDeviceGoodixMoc  *self,
+                   gxfp_cmd_response_t *resp,
+                   GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (resp->result != GX_SUCCESS)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_GENERAL,
+                                                     "Failed to enumerate fingers, result: 0x%x",
+                                                     resp->result));
+      return;
+    }
+  fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_CAPTURE);
+}
+
+static void
+fp_enroll_identify_cb (FpiDeviceGoodixMoc  *self,
+                       gxfp_cmd_response_t *resp,
+                       GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (resp->verify.match)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_DATA_DUPLICATE,
+                                                     "Finger is too similar to another, try use a different finger"));
+      // maybe need fpi_device_enroll_report_message ...
+      return;
+    }
+  fpi_ssm_next_state (self->task_ssm);
+
+}
+
+static void
+fp_enroll_init_cb (FpiDeviceGoodixMoc  *self,
+                   gxfp_cmd_response_t *resp,
+                   GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  memcpy (self->template_id, resp->enroll_init.tid, TEMPLATE_ID_SIZE);
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_enroll_capture_cb (FpiDeviceGoodixMoc  *self,
+                      gxfp_cmd_response_t *resp,
+                      GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  /* */
+  if (resp->result >= GX_FAILED)
+    {
+      fp_warn ("Capture sample failed, result: 0x%x", resp->result);
+      fpi_device_enroll_progress (FP_DEVICE (self),
+                                  self->enroll_stage,
+                                  NULL,
+                                  fpi_device_retry_new (FP_DEVICE_RETRY_GENERAL));
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_CAPTURE);
+      return;
+    }
+
+  if ((resp->capture_data_resp.img_quality < self->sensorcfg->config[4]) ||
+      (resp->capture_data_resp.img_coverage < self->sensorcfg->config[5]))
+    {
+      fp_warn ("Capture sample poor quality(%d): %d or coverage(%d): %d",
+               self->sensorcfg->config[4],
+               resp->capture_data_resp.img_quality,
+               self->sensorcfg->config[5],
+               resp->capture_data_resp.img_coverage);
+      fpi_device_enroll_progress (FP_DEVICE (self),
+                                  self->enroll_stage,
+                                  NULL,
+                                  fpi_device_retry_new (FP_DEVICE_RETRY_CENTER_FINGER));
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_CAPTURE);
+      return;
+    }
+  if (self->is_enroll_identify)
+    {
+      self->is_enroll_identify = false;
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_IDENTIFY);
+    }
+  else
+    {
+      fpi_ssm_next_state (self->task_ssm);
+    }
+
+}
+static void
+fp_enroll_update_cb (FpiDeviceGoodixMoc  *self,
+                     gxfp_cmd_response_t *resp,
+                     GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+
+  if (resp->enroll_update.img_preoverlay > self->sensorcfg->config[3])
+    {
+      fp_dbg ("Sample overlapping ratio is too High(%d): %d ",
+              self->sensorcfg->config[3],
+              resp->enroll_update.img_preoverlay);
+      /* here should tips move finger and try again */
+      fpi_device_enroll_progress (FP_DEVICE (self),
+                                  self->enroll_stage,
+                                  NULL,
+                                  fpi_device_retry_new (FP_DEVICE_RETRY_REMOVE_FINGER));
+    }
+  else if (resp->enroll_update.rollback)
+    {
+      fpi_device_enroll_progress (FP_DEVICE (self),
+                                  self->enroll_stage,
+                                  NULL,
+                                  fpi_device_retry_new (FP_DEVICE_RETRY_GENERAL));
+    }
+  else
+    {
+      self->enroll_stage++;
+      fpi_device_enroll_progress (FP_DEVICE (self), self->enroll_stage, NULL, NULL);
+    }
+  /* if enroll complete, no need to wait finger up */
+  if (self->enroll_stage >= self->max_enroll_stage)
+    {
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_CHECK_DUPLICATE);
+      return;
+    }
+
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_enroll_check_duplicate_cb (FpiDeviceGoodixMoc  *self,
+                              gxfp_cmd_response_t *resp,
+                              GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (resp->check_duplicate_resp.duplicate)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_DATA_DUPLICATE,
+                                                     "Finger has already enrolled"));
+      return;
+    }
+
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_enroll_commit_cb (FpiDeviceGoodixMoc  *self,
+                     gxfp_cmd_response_t *resp,
+                     GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  if (resp->result >= GX_FAILED)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Commit template failed with errcode: 0x%x", resp->result));
+      return;
+    }
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_finger_mode_cb (FpiDeviceGoodixMoc  *self,
+                   gxfp_cmd_response_t *resp,
+                   GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+  /* if reach max timeout(5sec) finger not up, swtich to finger up again */
+  if (resp->finger_status.status == GX_ERROR_WAIT_FINGER_UP_TIMEOUT)
+    {
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_WAIT_FINGER_UP);
+      return;
+    }
+  else if (resp->finger_status.status != GX_SUCCESS)
+    {
+      fpi_ssm_mark_failed (self->task_ssm,
+                           fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                     "Switch finger mode failed"));
+      return;
+    }
+  if (self->enroll_stage < self->max_enroll_stage)
+    {
+      fpi_ssm_jump_to_state (self->task_ssm, FP_ENROLL_CAPTURE);
+      return;
+    }
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_enroll_sm_run_state (FpiSsm *ssm, FpDevice *device)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  FpPrint *print = NULL;
+  GVariant *data = NULL;
+  GVariant *uid = NULL;
+  GVariant *tid = NULL;
+  guint finger;
+  guint16 user_id_len;
+  guint16 payload_len = 0;
+  g_autofree gchar *user_id = NULL;
+  g_autofree guint8 *payload = NULL;
+  guint8 dummy[3] = { 0 };
+
+  dummy[1] = self->sensorcfg->config[4];
+  dummy[2] = self->sensorcfg->config[5];
+
+  switch (fpi_ssm_get_cur_state (ssm))
+    {
+    case FP_ENROLL_ENUM:
+      {
+        goodix_sensor_cmd (self, MOC_CMD0_GETFINGERLIST, MOC_CMD1_DEFAULT,
+                           false,
+                           (const guint8 *) &dummy,
+                           1,
+                           fp_enroll_enum_cb);
+      }
+      break;
+
+    case FP_ENROLL_IDENTIFY:
+      {
+        dummy[0] = 0x01;
+        dummy[1] = self->sensorcfg->config[10];
+        dummy[2] = self->sensorcfg->config[11];
+        goodix_sensor_cmd (self, MOC_CMD0_IDENTIFY, MOC_CMD1_DEFAULT,
+                           false,
+                           (const guint8 *) &self->template_id,
+                           TEMPLATE_ID_SIZE,
+                           fp_enroll_identify_cb);
+      }
+      break;
+
+    case FP_ENROLL_CREATE:
+      {
+        goodix_sensor_cmd (self, MOC_CMD0_ENROLL_INIT, MOC_CMD1_DEFAULT,
+                           false,
+                           (const guint8 *) &dummy,
+                           1,
+                           fp_enroll_init_cb);
+      }
+      break;
+
+    case FP_ENROLL_CAPTURE:
+      goodix_sensor_cmd (self, MOC_CMD0_CAPTURE_DATA, MOC_CMD1_DEFAULT,
+                         true,
+                         (const guint8 *) &dummy,
+                         3,
+                         fp_enroll_capture_cb);
+      break;
+
+    case FP_ENROLL_UPDATE:
+      dummy[0] = 1;
+      dummy[1] = self->sensorcfg->config[2];
+      dummy[2] = self->sensorcfg->config[3];
+      goodix_sensor_cmd (self, MOC_CMD0_ENROLL, MOC_CMD1_DEFAULT,
+                         false,
+                         (const guint8 *) &dummy,
+                         3,
+                         fp_enroll_update_cb);
+      break;
+
+    case FP_ENROLL_WAIT_FINGER_UP:
+      dummy[0] = 0;
+      goodix_sensor_cmd (self, MOC_CMD0_FINGER_MODE, MOC_CMD1_SET_FINGER_UP,
+                         true,
+                         (const guint8 *) &dummy,
+                         1,
+                         fp_finger_mode_cb);
+      break;
+
+    case FP_ENROLL_CHECK_DUPLICATE:
+      goodix_sensor_cmd (self, MOC_CMD0_CHECK4DUPLICATE, MOC_CMD1_DEFAULT,
+                         false,
+                         (const guint8 *) &dummy,
+                         3,
+                         fp_enroll_check_duplicate_cb);
+      break;
+
+    case FP_ENROLL_COMMIT:
+      {
+        fpi_device_get_enroll_data (device, &print);
+        user_id = fpi_print_generate_user_id (print);
+        user_id_len = strlen (user_id);
+        user_id_len = MIN (100, user_id_len);
+        finger = 1;
+
+        if (g_strcmp0 (g_getenv ("FP_DEVICE_EMULATION"), "1") == 0)
+          memset (self->template_id, 0, TEMPLATE_ID_SIZE);
+        uid = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                         user_id,
+                                         user_id_len,
+                                         1);
+
+        tid = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                         self->template_id,
+                                         TEMPLATE_ID_SIZE,
+                                         1);
+
+        data = g_variant_new ("(y@ay@ay)",
+                              finger,
+                              tid,
+                              uid);
+
+        fpi_print_set_type (print, FPI_PRINT_RAW);
+        fpi_print_set_device_stored (print, TRUE);
+        g_object_set (print, "fpi-data", data, NULL);
+        g_object_set (print, "description", user_id, NULL);
+
+        g_debug ("user_id: %s, user_id_len: %d, finger: %d", user_id, user_id_len, finger);
+
+        if(!encode_finger_id (self->template_id,
+                              TEMPLATE_ID_SIZE,
+                              (guint8 *) user_id,
+                              user_id_len,
+                              &payload,
+                              &payload_len))
+          {
+            fpi_ssm_mark_failed (ssm,
+                                 fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                           "encode_finger_id failed"));
+            return;
+          }
+        goodix_sensor_cmd (self, MOC_CMD0_COMMITENROLLMENT, MOC_CMD1_DEFAULT,
+                           false,
+                           (const guint8 *) payload,
+                           payload_len,
+                           fp_enroll_commit_cb);
+
+      }
+      break;
+    }
+
+
+}
+
+static void
+fp_enroll_ssm_done (FpiSsm *ssm, FpDevice *dev, GError *error)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (dev);
+  FpPrint *print = NULL;
+
+  if (error)
+    {
+      fpi_device_enroll_complete (dev, NULL, error);
+      return;
+    }
+  fp_info ("Enrollment complete!");
+
+  fpi_device_get_enroll_data (FP_DEVICE (self), &print);
+
+  fpi_device_enroll_complete (FP_DEVICE (self), g_object_ref (print), NULL);
+
+  self->task_ssm = NULL;
+}
+/******************************************************************************
+ *
+ *  fp_init_xxxx Function
+ *
+ *****************************************************************************/
+static void
+fp_init_version_cb (FpiDeviceGoodixMoc  *self,
+                    gxfp_cmd_response_t *resp,
+                    GError              *error)
+{
+  char nullstring[GX_VERSION_LEN + 1] = { 0 };
+
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+
+  G_STATIC_ASSERT (sizeof (resp->version_info.fwtype) == 8);
+  G_STATIC_ASSERT (sizeof (resp->version_info.algversion) == 8);
+  G_STATIC_ASSERT (sizeof (resp->version_info.fwversion) == 8);
+
+  memcpy (nullstring, resp->version_info.fwtype, sizeof (resp->version_info.fwtype));
+  fp_info ("Firmware type: %s", nullstring);
+  memcpy (nullstring, resp->version_info.algversion, sizeof (resp->version_info.algversion));
+  fp_info ("Algversion version: %s", nullstring);
+  memcpy (nullstring, resp->version_info.fwversion, sizeof (resp->version_info.fwversion));
+  fp_info ("Firmware version: %s", nullstring);
+
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+static void
+fp_init_config_cb (FpiDeviceGoodixMoc  *self,
+                   gxfp_cmd_response_t *resp,
+                   GError              *error)
+{
+  if (error)
+    {
+      fpi_ssm_mark_failed (self->task_ssm, error);
+      return;
+    }
+
+  fpi_ssm_next_state (self->task_ssm);
+}
+
+
+static void
+fp_init_sm_run_state (FpiSsm *ssm, FpDevice *device)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  guint8 dummy = 0;
+
+  switch (fpi_ssm_get_cur_state (ssm))
+    {
+    case FP_INIT_VERSION:
+      goodix_sensor_cmd (self, MOC_CMD0_GET_VERSION, MOC_CMD1_DEFAULT,
+                         false,
+                         &dummy,
+                         1,
+                         fp_init_version_cb);
+      break;
+
+    case FP_INIT_CONFIG:
+      goodix_sensor_cmd (self, MOC_CMD0_UPDATE_CONFIG, MOC_CMD1_WRITE_CFG_TO_FLASH,
+                         false,
+                         (guint8 *) self->sensorcfg,
+                         sizeof (gxfp_sensor_cfg_t),
+                         fp_init_config_cb);
+      break;
+    }
+
+
+}
+
+static void
+fp_init_ssm_done (FpiSsm *ssm, FpDevice *dev, GError *error)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (dev);
+
+  if (error)
+    {
+      fpi_device_open_complete (dev, error);
+      return;
+    }
+  self->task_ssm = NULL;
+  fpi_device_open_complete (dev, NULL);
+}
+/******************************************************************************
+ *
+ *  fp_template_delete Function
+ *
+ *****************************************************************************/
+static gboolean
+parse_print_data (GVariant      *data,
+                  guint8        *finger,
+                  const guint8 **tid,
+                  gsize         *tid_len,
+                  const guint8 **user_id,
+                  gsize         *user_id_len)
+{
+  g_autoptr(GVariant) user_id_var = NULL;
+  g_autoptr(GVariant) tid_var = NULL;
+
+  g_return_val_if_fail (data != NULL, FALSE);
+  g_return_val_if_fail (finger != NULL, FALSE);
+  g_return_val_if_fail (tid != NULL, FALSE);
+  g_return_val_if_fail (tid_len != NULL, FALSE);
+  g_return_val_if_fail (user_id != NULL, FALSE);
+  g_return_val_if_fail (user_id_len != NULL, FALSE);
+
+  *tid = NULL;
+  *tid_len = 0;
+  *user_id = NULL;
+  *user_id_len = 0;
+
+
+  if (!g_variant_check_format_string (data, "(y@ay@ay)", FALSE))
+    return FALSE;
+
+  g_variant_get (data,
+                 "(y@ay@ay)",
+                 finger,
+                 &tid_var,
+                 &user_id_var);
+
+  *tid     = g_variant_get_fixed_array (tid_var, tid_len, 1);
+  *user_id = g_variant_get_fixed_array (user_id_var, user_id_len, 1);
+
+  if (*user_id_len == 0 || *user_id_len > 100)
+    return FALSE;
+
+  if (*user_id_len <= 0 || *user_id[0] == ' ')
+    return FALSE;
+
+  if(*tid_len != TEMPLATE_ID_SIZE)
+    return FALSE;
+
+  return TRUE;
+}
+
+static void
+fp_template_delete_cb (FpiDeviceGoodixMoc  *self,
+                       gxfp_cmd_response_t *resp,
+                       GError              *error)
+{
+  FpDevice *device = FP_DEVICE (self);
+
+  if (error)
+    {
+      fpi_device_delete_complete (device, error);
+      return;
+    }
+  if ((resp->result >= GX_FAILED) && (resp->result != GX_ERROR_FINGER_ID_NOEXIST))
+    {
+      fpi_device_delete_complete (FP_DEVICE (self),
+                                  fpi_device_error_new_msg (FP_DEVICE_ERROR_GENERAL,
+                                                            "Failed delete enrolled users, result: 0x%x",
+                                                            resp->result));
+      return;
+    }
+
+  fp_info ("Successfully deleted enrolled user");
+  fpi_device_delete_complete (device, NULL);
+}
+/******************************************************************************
+ *
+ *  fp_template_list Function
+ *
+ *****************************************************************************/
+static void
+fp_template_list_cb (FpiDeviceGoodixMoc  *self,
+                     gxfp_cmd_response_t *resp,
+                     GError              *error)
+{
+  FpDevice *device = FP_DEVICE (self);
+
+  if (error)
+    {
+      fpi_device_list_complete (FP_DEVICE (self), NULL, error);
+      return;
+    }
+  if (resp->result != GX_SUCCESS)
+    {
+      fp_info ("Failed to query enrolled users: %d", resp->result);
+      fpi_device_list_complete (FP_DEVICE (self),
+                                NULL,
+                                fpi_device_error_new_msg (FP_DEVICE_ERROR_GENERAL,
+                                                          "Failed to query enrolled users, result: 0x%x",
+                                                          resp->result));
+      return;
+    }
+
+  self->list_result = g_ptr_array_new_with_free_func (g_object_unref);
+
+  if(resp->finger_list_resp.finger_num == 0)
+    {
+      fp_info ("Database is empty");
+      fpi_device_list_complete (device,
+                                g_steal_pointer (&self->list_result),
+                                NULL);
+      return;
+    }
+
+  for (int n = 0; n < resp->finger_list_resp.finger_num; n++)
+    {
+      GVariant *data = NULL;
+      GVariant *tid = NULL;
+      GVariant *uid = NULL;
+      FpPrint *print;
+      gchar *userid;
+
+      userid = (gchar *) resp->finger_list_resp.finger_list[n].payload.data;
+
+      print = fp_print_new (FP_DEVICE (self));
+
+      tid = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                       resp->finger_list_resp.finger_list[n].tid,
+                                       TEMPLATE_ID_SIZE,
+                                       1);
+
+      uid = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                       resp->finger_list_resp.finger_list[n].payload.data,
+                                       resp->finger_list_resp.finger_list[n].payload.size,
+                                       1);
+
+      data = g_variant_new ("(y@ay@ay)",
+                            resp->finger_list_resp.finger_list[n].finger_index,
+                            tid,
+                            uid);
+
+      fpi_print_set_type (print, FPI_PRINT_RAW);
+      fpi_print_set_device_stored (print, TRUE);
+      g_object_set (print, "fpi-data", data, NULL);
+      g_object_set (print, "description", userid, NULL);
+      fpi_print_fill_from_user_id (print, userid);
+      g_ptr_array_add (self->list_result, g_object_ref_sink (print));
+    }
+
+  fp_info ("Query complete!");
+  fpi_device_list_complete (device,
+                            g_steal_pointer (&self->list_result),
+                            NULL);
+
+}
+
+/******************************************************************************
+ *
+ *  Interface Function
+ *
+ *****************************************************************************/
+static void
+gx_fp_probe (FpDevice *device)
+{
+  GUsbDevice *usb_dev;
+  GError *error = NULL;
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  g_autofree gchar *serial = NULL;
+  gint productid = 0;
+
+  /* Claim usb interface */
+  usb_dev = fpi_device_get_usb_device (device);
+  if (!g_usb_device_open (usb_dev, &error))
+    {
+      fpi_device_probe_complete (device, NULL, NULL, error);
+      return;
+    }
+
+  if (!g_usb_device_reset (usb_dev, &error))
+    goto err_close;
+
+  if (!g_usb_device_claim_interface (usb_dev, 0, 0, &error))
+    goto err_close;
+
+  if (g_strcmp0 (g_getenv ("FP_DEVICE_EMULATION"), "1") == 0)
+    {
+
+      serial = g_strdup ("emulated-device");
+    }
+  else
+    {
+      serial = g_usb_device_get_string_descriptor (usb_dev,
+                                                   g_usb_device_get_serial_number_index (usb_dev),
+                                                   &error);
+
+      if (serial && !g_str_has_suffix (serial, "B0"))
+        fp_warn ("Device with serial %s not supported", serial);
+      if (error)
+        {
+          g_usb_device_release_interface (fpi_device_get_usb_device (FP_DEVICE (device)),
+                                          0, 0, NULL);
+          goto err_close;
+        }
+    }
+  productid = g_usb_device_get_pid (usb_dev);
+  switch (productid)
+    {
+    case 0x6496:
+    case 0x60A2:
+      self->max_enroll_stage = 12;
+      break;
+
+    default:
+      self->max_enroll_stage = DEFAULT_ENROLL_SAMPLES;
+      break;
+    }
+
+  fpi_device_set_nr_enroll_stages (device, self->max_enroll_stage);
+
+  g_usb_device_close (usb_dev, NULL);
+  fpi_device_probe_complete (device, serial, NULL, error);
+  return;
+err_close:
+
+  g_usb_device_close (usb_dev, NULL);
+  fpi_device_probe_complete (device, NULL, NULL, error);
+
+}
+
+static void
+gx_fp_init (FpDevice *device)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  GError *error = NULL;
+  int ret = 0;
+
+  self->cancellable = g_cancellable_new ();
+
+  self->sensorcfg = g_new0 (gxfp_sensor_cfg_t, 1);
+
+  ret = gx_proto_init_sensor_config (self->sensorcfg);
+  if (ret != 0)
+    {
+      error = fpi_device_error_new_msg (FP_DEVICE_ERROR_GENERAL, "Init sensor failed");
+      fpi_device_open_complete (FP_DEVICE (self), error);
+      return;
+    }
+  self->sensorcfg->config[6] = self->max_enroll_stage;
+
+  if (!g_usb_device_reset (fpi_device_get_usb_device (device), &error))
+    {
+      fpi_device_open_complete (FP_DEVICE (self), error);
+      return;
+    }
+
+  /* Claim usb interface */
+  if (!g_usb_device_claim_interface (fpi_device_get_usb_device (device), 0, 0, &error))
+    {
+      fpi_device_open_complete (FP_DEVICE (self), error);
+      return;
+    }
+
+  self->task_ssm = fpi_ssm_new (device, fp_init_sm_run_state,
+                                FP_INIT_NUM_STATES);
+
+  fpi_ssm_start (self->task_ssm, fp_init_ssm_done);
+
+}
+
+static void
+gx_fp_exit (FpDevice *device)
+{
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  GError *error = NULL;
+
+  g_clear_object (&self->cancellable);
+  g_clear_pointer (&self->sensorcfg, g_free);
+
+  /* Release usb interface */
+  g_usb_device_release_interface (fpi_device_get_usb_device (FP_DEVICE (device)),
+                                  0, 0, &error);
+
+  /* Notify close complete */
+  fpi_device_close_complete (FP_DEVICE (self), error);
+}
+
+
+static void
+gx_fp_verify (FpDevice *device)
+{
+
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  FpPrint *print = NULL;
+
+  g_autoptr(GVariant) data = NULL;
+  guint8 finger;
+  const guint8 *user_id;
+  gsize user_id_len = 0;
+  const guint8 *tid;
+  gsize tid_len = 0;
+
+  fpi_device_get_verify_data (device, &print);
+
+  g_object_get (print, "fpi-data", &data, NULL);
+
+  if (!parse_print_data (data, &finger, &tid, &tid_len, &user_id, &user_id_len))
+    {
+      fpi_device_verify_complete (device,
+                                  fpi_device_error_new (FP_DEVICE_ERROR_DATA_INVALID));
+      return;
+    }
+  memcpy (&self->template_id, tid, tid_len);
+
+  self->task_ssm = fpi_ssm_new (device, fp_verify_sm_run_state,
+                                FP_VERIFY_NUM_STATES);
+
+  fpi_ssm_start (self->task_ssm, fp_verify_ssm_done);
+
+}
+
+static void
+gx_fp_enroll (FpDevice *device)
+{
+
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+
+  self->enroll_stage = 0;
+  self->is_enroll_identify = true;
+
+  self->task_ssm = fpi_ssm_new (device, fp_enroll_sm_run_state,
+                                FP_ENROLL_NUM_STATES);
+
+  fpi_ssm_start (self->task_ssm, fp_enroll_ssm_done);
+
+}
+
+
+static void
+gx_fp_template_list (FpDevice *device)
+{
+
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  guint8 dummy[1] = { 0 };
+
+  G_DEBUG_HERE ();
+
+  goodix_sensor_cmd (self, MOC_CMD0_GETFINGERLIST, MOC_CMD1_DEFAULT,
+                     false,
+                     (const guint8 *) &dummy,
+                     1,
+                     fp_template_list_cb);
+}
+
+
+
+static void
+gx_fp_template_delete (FpDevice *device)
+{
+
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+  FpPrint *print = NULL;
+
+  g_autoptr(GVariant) data = NULL;
+  guint8 finger;
+  const guint8 *user_id;
+  gsize user_id_len = 0;
+  const guint8 *tid;
+  gsize tid_len = 0;
+  gsize payload_len = 0;
+  g_autofree guint8 *payload = NULL;
+
+  fpi_device_get_delete_data (device, &print);
+
+  g_object_get (print, "fpi-data", &data, NULL);
+
+  if (!parse_print_data (data, &finger, &tid, &tid_len, &user_id, &user_id_len))
+    {
+      fpi_device_delete_complete (device,
+                                  fpi_device_error_new (FP_DEVICE_ERROR_DATA_INVALID));
+      return;
+    }
+  if (!encode_finger_id (tid, tid_len, user_id, user_id_len, &payload, (guint16 *) &payload_len))
+    {
+      fpi_device_delete_complete (device,
+                                  fpi_device_error_new_msg (FP_DEVICE_ERROR_PROTO,
+                                                            "encode_finger_id failed"));
+      return;
+    }
+
+  goodix_sensor_cmd (self, MOC_CMD0_DELETETEMPLATE, MOC_CMD1_DEFAULT,
+                     false,
+                     (const guint8 *) payload,
+                     payload_len,
+                     fp_template_delete_cb);
+
+}
+
+static void
+fpi_device_goodixmoc_init (FpiDeviceGoodixMoc *self)
+{
+
+}
+
+static void
+gx_fp_cancel (FpDevice *device)
+{
+
+  FpiDeviceGoodixMoc *self = FPI_DEVICE_GOODIXMOC (device);
+
+  /* Cancel any current interrupt transfer (resulting us to go into
+   * response reading mode again); then create a new cancellable
+   * for the next transfers. */
+  g_cancellable_cancel (self->cancellable);
+  g_clear_object (&self->cancellable);
+  self->cancellable = g_cancellable_new ();
+
+}
+
+static const FpIdEntry id_table[] = {
+  { .vid = 0x27c6,  .pid = 0x5840,  },
+  { .vid = 0x27c6,  .pid = 0x6496,  },
+  { .vid = 0x27c6,  .pid = 0x60A2,  },
+  { .vid = 0,  .pid = 0,  .driver_data = 0 },   /* terminating entry */
+};
+
+
+static void
+fpi_device_goodixmoc_class_init (FpiDeviceGoodixMocClass *klass)
+{
+  FpDeviceClass *dev_class = FP_DEVICE_CLASS (klass);
+
+  dev_class->id = "goodixmoc";
+  dev_class->full_name = "Goodix MOC Fingerprint Sensor";
+  dev_class->type = FP_DEVICE_TYPE_USB;
+  dev_class->scan_type = FP_SCAN_TYPE_PRESS;
+  dev_class->id_table = id_table;
+  dev_class->nr_enroll_stages = DEFAULT_ENROLL_SAMPLES;
+
+  dev_class->open   = gx_fp_init;
+  dev_class->close  = gx_fp_exit;
+  dev_class->probe  = gx_fp_probe;
+  dev_class->verify = gx_fp_verify;
+  dev_class->enroll = gx_fp_enroll;
+  dev_class->delete = gx_fp_template_delete;
+  dev_class->list   = gx_fp_template_list;
+  dev_class->cancel = gx_fp_cancel;
+}
diff --git a/libfprint/drivers/goodixmoc/goodix.h b/libfprint/drivers/goodixmoc/goodix.h
new file mode 100644
index 0000000..c38bf9b
--- /dev/null
+++ b/libfprint/drivers/goodixmoc/goodix.h
@@ -0,0 +1,58 @@
+/*
+ * Goodix Moc driver for libfprint
+ * Copyright (C) 2019 Shenzhen Goodix Technology Co., Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include "fpi-device.h"
+#include "fpi-ssm.h"
+
+G_DECLARE_FINAL_TYPE (FpiDeviceGoodixMoc, fpi_device_goodixmoc, FPI, DEVICE_GOODIXMOC, FpDevice)
+
+typedef enum {
+  FP_CMD_SEND = 0,
+  FP_CMD_GET_ACK,
+  FP_CMD_GET_DATA,
+  FP_CMD_NUM_STATES,
+} FpCmdState;
+
+
+typedef enum {
+  FP_INIT_VERSION = 0,
+  FP_INIT_CONFIG,
+  FP_INIT_NUM_STATES,
+} FpInitState;
+
+
+typedef enum {
+  FP_ENROLL_ENUM = 0,
+  FP_ENROLL_IDENTIFY,
+  FP_ENROLL_CREATE,
+  FP_ENROLL_CAPTURE,
+  FP_ENROLL_UPDATE,
+  FP_ENROLL_WAIT_FINGER_UP,
+  FP_ENROLL_CHECK_DUPLICATE,
+  FP_ENROLL_COMMIT,
+  FP_ENROLL_NUM_STATES,
+} FpEnrollState;
+
+typedef enum {
+  FP_VERIFY_CAPTURE = 0,
+  FP_VERIFY_IDENTIFY,
+  FP_VERIFY_NUM_STATES,
+} FpVerifyState;
diff --git a/libfprint/drivers/goodixmoc/goodix_proto.c b/libfprint/drivers/goodixmoc/goodix_proto.c
new file mode 100644
index 0000000..3174170
--- /dev/null
+++ b/libfprint/drivers/goodixmoc/goodix_proto.c
@@ -0,0 +1,422 @@
+/*
+ * Goodix Moc driver for libfprint
+ * Copyright (C) 2019 Shenzhen Goodix Technology Co., Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <glib.h>
+#include "goodix_proto.h"
+
+/*
+ *  Crc functions
+ */
+
+#define WIDTH (8 * sizeof (uint32_t))
+#define FINAL_XOR_VALUE 0xFFFFFFFF
+#define REFLECT_DATA(X)         ((uint8_t) reflect ((X), 8))
+#define REFLECT_REMAINDER(X)    ((unsigned int) reflect ((X), WIDTH))
+
+
+uint8_t
+gx_proto_crc8_calc (uint8_t *lubp_date, uint32_t lui_len)
+{
+  const uint8_t *data = lubp_date;
+  unsigned int crc = 0;
+  int i, j;
+
+  for (j = lui_len; j; j--, data++)
+    {
+      crc ^= (*data << 8);
+      for (i = 8; i; i--)
+        {
+          if (crc & 0x8000)
+            crc ^= (0x1070 << 3);
+          crc <<= 1;
+        }
+    }
+
+  crc >>= 8;
+  crc = ~crc;
+  return (uint8_t) crc;
+}
+
+typedef struct
+{
+  uint32_t crc;
+} gf_crc32_context;
+
+static uint32_t s_crc_table[256] =
+{ 0x0,         0x4c11db7,  0x9823b6e,  0xd4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
+  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
+  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
+  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
+  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x18aeb13,   0x54bf6a4,  0x808d07d,  0xcc9cdca,
+  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
+  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
+  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
+  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
+  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
+  0x315d626,  0x7d4cb91,  0xa97ed48,  0xe56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
+  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
+  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
+  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
+  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x29f3d35,  0x65e2082,   0xb1d065b,  0xfdc1bec,
+  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
+  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
+  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
+  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};
+
+static uint32_t
+reflect (uint32_t data, uint8_t n_bits)
+{
+  unsigned long reflection = 0x00000000;
+  uint8_t bit;
+
+  /*
+   * Reflect the data about the center bit.
+   */
+  for (bit = 0; bit < n_bits; ++bit)
+    {
+      /*
+       * If the LSB bit is set, set the reflection of it.
+       */
+      if (data & 0x01)
+        reflection |= (1 << ((n_bits - 1) - bit));
+
+      data = (data >> 1);
+    }
+
+  return reflection;
+
+}
+
+static void
+crc32_init (gf_crc32_context *ctx)
+{
+  ctx->crc = 0xFFFFFFFF;
+}
+
+static void
+crc32_update (gf_crc32_context *ctx, const uint8_t *message, uint32_t n_bytes)
+{
+  uint8_t data;
+  uint32_t byte;
+
+  /*
+   * Divide the message by the polynomial, a byte at a time.
+   */
+  for (byte = 0; byte < n_bytes; ++byte)
+    {
+      data = REFLECT_DATA (message[byte]) ^ (ctx->crc >> (WIDTH - 8));
+      ctx->crc = s_crc_table[data] ^ (ctx->crc << 8);
+    }
+}
+
+static void
+crc32_final (gf_crc32_context *ctx, uint8_t *md)
+{
+  ctx->crc = (REFLECT_REMAINDER (ctx->crc) ^ FINAL_XOR_VALUE);
+  memcpy (md, &ctx->crc, 4);
+}
+
+uint8_t
+gx_proto_crc32_calc (uint8_t *pchMsg, uint32_t wDataLen, uint8_t *pchMsgDst)
+{
+  gf_crc32_context context = { 0 };
+
+  if (!pchMsg)
+    return 0;
+
+  crc32_init (&context);
+
+  crc32_update (&context, pchMsg, wDataLen);
+
+  crc32_final (&context, pchMsgDst);
+
+
+  return 1;
+}
+/*
+ *  protocol
+ *
+ */
+
+static uint8_t dump_seq = 0;
+
+static void
+init_pack_header (
+  ppack_header pheader,
+  uint16_t     len,
+  uint16_t     cmd,
+  uint8_t      packagenum
+                 )
+{
+  g_assert (pheader);
+
+  memset (pheader, 0, sizeof (*pheader));
+  pheader->cmd0 = HIBYTE (cmd);
+  pheader->cmd1 = LOBYTE (cmd);
+  pheader->packagenum = packagenum;
+  pheader->reserved = dump_seq++;
+  pheader->len = len + PACKAGE_CRC_SIZE;
+  pheader->crc8 = gx_proto_crc8_calc ((uint8_t *) pheader, 6);
+  pheader->rev_crc8 = ~pheader->crc8;
+}
+
+
+int
+gx_proto_build_package (uint8_t       *ppackage,
+                        uint32_t      *package_len,
+                        uint16_t       cmd,
+                        const uint8_t *payload,
+                        uint32_t       payload_size)
+{
+  pack_header header;
+
+  if (!ppackage || !package_len)
+    return -1;
+
+  if(*package_len < (payload_size + PACKAGE_HEADER_SIZE + PACKAGE_CRC_SIZE))
+    return -1;
+
+  init_pack_header (&header, payload_size, cmd, 0);
+
+  memcpy (ppackage, &header, PACKAGE_HEADER_SIZE);
+  memcpy (ppackage + PACKAGE_HEADER_SIZE, payload, payload_size);
+
+  gx_proto_crc32_calc (ppackage, PACKAGE_HEADER_SIZE + payload_size, ppackage + PACKAGE_HEADER_SIZE + payload_size);
+
+  return 0;
+}
+
+
+int
+gx_proto_parse_header (
+  uint8_t     *buffer,
+  uint32_t     buffer_len,
+  pack_header *pheader)
+{
+  if (!buffer || !pheader)
+    return -1;
+  if (buffer_len < PACKAGE_HEADER_SIZE)
+    return -1;
+
+  memcpy (pheader, buffer, sizeof (pack_header));
+
+  pheader->len = GUINT16_FROM_LE (*(buffer + 4));
+  pheader->len -= PACKAGE_CRC_SIZE;
+
+  return 0;
+}
+
+static int
+gx_proto_parse_fingerid (
+  uint8_t          * fid_buffer,
+  uint16_t           fid_buffer_size,
+  ptemplate_format_t template
+                        )
+{
+  uint8_t * buffer = NULL;
+  uint16_t Offset = 0;
+
+  if (!template || !fid_buffer)
+    return -1;
+
+  if (fid_buffer_size < 70)
+    return -1;
+
+  buffer = fid_buffer;
+  Offset = 0;
+
+  if (buffer[Offset++] != 67)
+    return -1;
+
+  template->type = buffer[Offset++];
+  template->finger_index = buffer[Offset++];
+  Offset++;
+
+  memcpy (template->accountid, &buffer[Offset], 32);
+  Offset += 32;
+
+  memcpy (template->tid, &buffer[Offset], 32);
+  Offset += 32;   // Offset == 68
+
+  template->payload.size = buffer[Offset++];
+  memset (template->payload.data, 0, 56);
+  memcpy (template->payload.data, &buffer[Offset], template->payload.size);
+
+  return 0;
+}
+
+int
+gx_proto_parse_body (uint16_t cmd, uint8_t *buffer, uint32_t buffer_len, pgxfp_cmd_response_t presp)
+{
+  uint32_t offset = 0;
+  uint8_t *fingerlist = NULL;
+
+  if (!buffer || !presp)
+    return -1;
+  if (buffer_len < 1)
+    return -1;
+  presp->result = buffer[0];
+  switch (HIBYTE (cmd))
+    {
+    case RESPONSE_PACKAGE_CMD:
+      {
+        presp->parse_msg.ack_cmd = buffer[1];
+      }
+      break;
+
+    case MOC_CMD0_UPDATE_CONFIG:
+    case MOC_CMD0_COMMITENROLLMENT:
+    case MOC_CMD0_DELETETEMPLATE:
+      break;
+
+    case MOC_CMD0_GET_VERSION:
+      memcpy (&presp->version_info, buffer + 1, sizeof (gxfp_version_info_t));
+      break;
+
+    case MOC_CMD0_CAPTURE_DATA:
+      if (LOBYTE (cmd) == MOC_CMD1_DEFAULT)
+        {
+          presp->capture_data_resp.img_quality  = buffer[1];
+          presp->capture_data_resp.img_coverage = buffer[2];
+        }
+      break;
+
+    case MOC_CMD0_ENROLL_INIT:
+      if (presp->result == GX_SUCCESS)
+        memcpy (&presp->enroll_init.tid, &buffer[1], TEMPLATE_ID_SIZE);
+      break;
+
+    case MOC_CMD0_ENROLL:
+      presp->enroll_update.rollback = (buffer[0] < 0x80) ? false : true;
+      presp->enroll_update.img_overlay    = buffer[1];
+      presp->enroll_update.img_preoverlay = buffer[2];
+      break;
+
+    case MOC_CMD0_CHECK4DUPLICATE:
+      presp->check_duplicate_resp.duplicate = (presp->result == 0) ? false : true;
+      if (presp->check_duplicate_resp.duplicate)
+        {
+          uint16_t tid_size = GUINT16_FROM_LE (*(buffer + 1));
+          memcpy (&presp->check_duplicate_resp.template, buffer + 3, tid_size);
+        }
+      break;
+
+    case MOC_CMD0_GETFINGERLIST:
+      if (presp->result != GX_SUCCESS)
+        break;
+      presp->finger_list_resp.finger_num = buffer[1];
+      if (presp->finger_list_resp.finger_num > FP_MAX_FINGERNUM)
+        {
+          presp->finger_list_resp.finger_num = 0;
+          presp->result = GX_ERROR_NO_AVAILABLE_SPACE;
+          break;
+        }
+      fingerlist = buffer + 2;
+      for(uint8_t num = 0; num < presp->finger_list_resp.finger_num; num++)
+        {
+          uint16_t fingerid_length = GUINT16_FROM_LE (*(fingerlist + offset));
+          offset += 2;
+          if (gx_proto_parse_fingerid (fingerlist + offset,
+                                       fingerid_length,
+                                       &presp->finger_list_resp.finger_list[num]) != 0)
+            {
+              g_error ("parse fingerlist error");
+              presp->finger_list_resp.finger_num = 0;
+              presp->result = GX_FAILED;
+              break;
+            }
+          offset += fingerid_length;
+        }
+      break;
+
+    case MOC_CMD0_IDENTIFY:
+      {
+        uint32_t score = 0;
+        uint8_t study = 0;
+        uint16_t fingerid_size = 0;
+        presp->verify.match = (buffer[0] == 0) ? true : false;
+        if (presp->verify.match)
+          {
+            offset += 1;
+            presp->verify.rejectdetail = GUINT16_FROM_LE (*(buffer + offset));
+            offset += 2;
+            score = GUINT32_FROM_LE (*(buffer + offset));
+            offset += 4;
+            study = GUINT16_FROM_LE (*(buffer + offset));
+            offset += 1;
+            fingerid_size = GUINT16_FROM_LE (*(buffer + offset));
+            offset += 2;
+            if (gx_proto_parse_fingerid (buffer + offset, fingerid_size, &presp->verify.template) != 0)
+              {
+                presp->result = GX_FAILED;
+                break;
+              }
+            g_debug ("match, score: %d, study: %d", score, study);
+          }
+      }
+      break;
+
+    case MOC_CMD0_FINGER_MODE:
+      presp->finger_status.status = buffer[0];
+      break;
+
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+static uint8_t sensor_config[26] = {
+  0x00, 0x00, 0x64, 0x50, 0x0f, 0x41, 0x08, 0x0a, 0x18, 0x00, 0x00, 0x23, 0x00,
+  0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x05, 0x05
+};
+
+int
+gx_proto_init_sensor_config (pgxfp_sensor_cfg_t pconfig)
+{
+  uint32_t crc32_calc = 0;
+
+  if (!pconfig)
+    return -1;
+  memset (pconfig, 0, sizeof (*pconfig));
+
+  //NOTICE: Do not change any value!
+  memcpy (&pconfig->config, sensor_config, 26);
+  pconfig->reserved[0] = 1;
+
+  gx_proto_crc32_calc ((uint8_t *) pconfig, sizeof (*pconfig) - PACKAGE_CRC_SIZE, (uint8_t *) &crc32_calc);
+
+  memcpy (pconfig->crc_value, &crc32_calc, PACKAGE_CRC_SIZE);
+
+  return 0;
+}
\ No newline at end of file
diff --git a/libfprint/drivers/goodixmoc/goodix_proto.h b/libfprint/drivers/goodixmoc/goodix_proto.h
new file mode 100644
index 0000000..1611a60
--- /dev/null
+++ b/libfprint/drivers/goodixmoc/goodix_proto.h
@@ -0,0 +1,232 @@
+/*
+ * Goodix Moc driver for libfprint
+ * Copyright (C) 2019 Shenzhen Goodix Technology Co., Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+
+#define PACKAGE_CRC_SIZE (4)
+#define PACKAGE_HEADER_SIZE (8)
+
+#define FP_MAX_FINGERNUM (10)
+
+#define TEMPLATE_ID_SIZE (32)
+
+#define GX_VERSION_LEN (8)
+
+/* Type covert */
+#define MAKE_CMD_EX(cmd0, cmd1)    ((uint16_t) (((cmd0) << 8) | (cmd1)))
+#define LOBYTE(value) ((uint8_t) (value))
+#define HIBYTE(value) ((uint8_t) (((uint16_t) (value) >> 8) & 0xFF))
+
+
+/* Error code */
+#define GX_SUCCESS 0x00
+#define GX_FAILED 0x80
+#define GX_ERROR_FINGER_ID_NOEXIST 0x9C
+#define GX_ERROR_TEMPLATE_INCOMPLETE 0xB8
+#define GX_ERROR_WAIT_FINGER_UP_TIMEOUT 0xC7
+#define GX_ERROR_NO_AVAILABLE_SPACE 0x8F
+
+/* Command Type Define */
+#define RESPONSE_PACKAGE_CMD 0xAA
+
+#define MOC_CMD0_ENROLL 0xA0
+#define MOC_CMD0_ENROLL_INIT 0xA1
+#define MOC_CMD0_CAPTURE_DATA 0xA2
+#define MOC_CMD0_CHECK4DUPLICATE 0xA3
+#define MOC_CMD0_COMMITENROLLMENT 0xA4
+
+#define MOC_CMD0_IDENTIFY 0xA5
+#define MOC_CMD0_GETFINGERLIST 0xA6
+#define MOC_CMD0_DELETETEMPLATE 0xA7
+
+#define MOC_CMD1_DEFAULT 0x00
+#define MOC_CMD1_UNTIL_DOWN 0x00
+#define MOC_CMD1_WHEN_DOWN 0x01
+
+#define MOC_CMD1_DELETE_TEMPLATE 0x04
+#define MOC_CMD1_DELETE_ALL 0x01
+
+#define MOC_CMD0_GET_VERSION 0xD0
+
+#define MOC_CMD0_UPDATE_CONFIG 0xC0
+#define MOC_CMD1_NWRITE_CFG_TO_FLASH 0x00
+#define MOC_CMD1_WRITE_CFG_TO_FLASH 0x01
+
+#define MOC_CMD0_FINGER_MODE 0xB0
+#define MOC_CMD1_GET_FINGER_MODE 0x00
+#define MOC_CMD1_SET_FINGER_DOWN 0x01
+#define MOC_CMD1_SET_FINGER_UP 0x02
+/* */
+
+typedef struct _gxfp_version_info
+{
+  uint8_t format[2];
+  uint8_t fwtype[GX_VERSION_LEN];
+  uint8_t fwversion[GX_VERSION_LEN];
+  uint8_t customer[GX_VERSION_LEN];
+  uint8_t mcu[GX_VERSION_LEN];
+  uint8_t sensor[GX_VERSION_LEN];
+  uint8_t algversion[GX_VERSION_LEN];
+  uint8_t interface[GX_VERSION_LEN];
+  uint8_t protocol[GX_VERSION_LEN];
+  uint8_t flashVersion[GX_VERSION_LEN];
+  uint8_t reserved[62];
+} gxfp_version_info_t, *pgxfp_version_info_t;
+
+
+typedef struct _gxfp_parse_msg
+{
+  uint8_t ack_cmd;
+  bool    has_no_config;
+} gxfp_parse_msg_t, *pgxfp_parse_msg_t;
+
+
+typedef struct _gxfp_enroll_init
+{
+  uint8_t tid[TEMPLATE_ID_SIZE];
+} gxfp_enroll_init_t, *pgxfp_enroll_init_t;
+
+#pragma pack(push, 1)
+typedef struct _template_format
+{
+  uint8_t type;
+  uint8_t finger_index;
+  uint8_t accountid[32];
+  uint8_t tid[32];
+  struct
+  {
+    uint32_t size;
+    uint8_t  data[56];
+  } payload;
+  uint8_t reserve[2];
+} template_format_t, *ptemplate_format_t;
+
+#pragma pack(pop)
+
+
+typedef struct _gxfp_verify
+{
+  bool     match;
+  uint32_t rejectdetail;
+  template_format_t  template;
+} gxfp_verify_t, *pgxfp_verify_t;
+
+
+typedef struct _gxfp_capturedata
+{
+  uint8_t img_quality;
+  uint8_t img_coverage;
+} gxfp_capturedata_t, *pgxfp_capturedata_t;
+
+typedef struct _gxfp_check_duplicate
+{
+  bool duplicate;
+  template_format_t  template;
+} gxfp_check_duplicate_t, *pgxfp_check_duplicate_t;
+
+
+typedef struct _gxfp_enroll_update
+{
+  bool    rollback;
+  uint8_t img_overlay;
+  uint8_t img_preoverlay;
+} gxfp_enroll_update_t, *Pgxfp_enroll_update_t;
+
+typedef struct _gxfp_enum_fingerlist
+{
+  uint8_t           finger_num;
+  template_format_t finger_list[FP_MAX_FINGERNUM];
+} gxfp_enum_fingerlist_t, *pgxfp_enum_fingerlist_t;
+
+typedef struct _gxfp_enroll_commit
+{
+  uint8_t result;
+} gxfp_enroll_commit_t, *pgxfp_enroll_commit_t;
+
+typedef struct _fp_finger_status
+{
+  uint8_t status;
+} fp_finger_status_t, *pfp_finger_status_t;
+
+
+typedef struct _fp_cmd_response
+{
+  uint8_t result;
+  union
+  {
+    gxfp_parse_msg_t       parse_msg;
+    gxfp_verify_t          verify;
+    gxfp_enroll_init_t     enroll_init;
+    gxfp_capturedata_t     capture_data_resp;
+    gxfp_check_duplicate_t check_duplicate_resp;
+    gxfp_enroll_commit_t   enroll_commit;
+    gxfp_enroll_update_t   enroll_update;
+    gxfp_enum_fingerlist_t finger_list_resp;
+    gxfp_version_info_t    version_info;
+    fp_finger_status_t     finger_status;
+  };
+} gxfp_cmd_response_t, *pgxfp_cmd_response_t;
+
+
+typedef struct _pack_header
+{
+  uint8_t  cmd0;
+  uint8_t  cmd1;
+  uint8_t  packagenum;
+  uint8_t  reserved;
+  uint16_t len;
+  uint8_t  crc8;
+  uint8_t  rev_crc8;
+} pack_header, *ppack_header;
+
+
+typedef struct _gxfp_sensor_cfg
+{
+  uint8_t config[26];
+  uint8_t reserved[98];
+  uint8_t crc_value[4];
+} gxfp_sensor_cfg_t, *pgxfp_sensor_cfg_t;
+/* */
+
+int gx_proto_build_package (uint8_t       *ppackage,
+                            uint32_t      *package_len,
+                            uint16_t       cmd,
+                            const uint8_t *payload,
+                            uint32_t       payload_size);
+
+int gx_proto_parse_header (uint8_t     *buffer,
+                           uint32_t     buffer_len,
+                           pack_header *pheader);
+
+int gx_proto_parse_body (uint16_t             cmd,
+                         uint8_t             *buffer,
+                         uint32_t             buffer_len,
+                         pgxfp_cmd_response_t presponse);
+
+int gx_proto_init_sensor_config (pgxfp_sensor_cfg_t pconfig);
+
+uint8_t gx_proto_crc8_calc (uint8_t *lubp_date,
+                            uint32_t lui_len);
+
+uint8_t gx_proto_crc32_calc (uint8_t *pchMsg,
+                             uint32_t wDataLen,
+                             uint8_t *pchMsgDst);
diff --git a/libfprint/meson.build b/libfprint/meson.build
index 78448ce..317e4c2 100644
--- a/libfprint/meson.build
+++ b/libfprint/meson.build
@@ -161,6 +161,12 @@ foreach driver: drivers
         'drivers/synaptics/bmkt_message.c',
     ]
     endif
+    if driver == 'goodixmoc'
+    drivers_sources += [
+        'drivers/goodixmoc/goodix.c',
+        'drivers/goodixmoc/goodix_proto.c',
+    ]
+    endif
 endforeach
 
 if aeslib
diff --git a/meson.build b/meson.build
index bab3f52..9164541 100644
--- a/meson.build
+++ b/meson.build
@@ -110,6 +110,7 @@ default_drivers = [
     'upektc',
     'upeksonly',
     'upekts',
+    'goodixmoc',
 ]
 
 all_drivers = default_drivers + virtual_drivers
